/*!
 * json-crawl v0.4.2
 * Copyright (C) 2012-2023 Damir Yusipov
 * Date: Wed, 13 Dec 2023 19:13:27 GMT
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).JsonCrawl={})}(this,(function(e){"use strict";function t(e,t){var n={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&t.indexOf(o)<0&&(n[o]=e[o]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(o=Object.getOwnPropertySymbols(e);s<o.length;s++)t.indexOf(o[s])<0&&Object.prototype.propertyIsEnumerable.call(e,o[s])&&(n[o[s]]=e[o[s]])}return n}function n(e,t,n,o){return new(n||(n=Promise))((function(s,a){function r(e){try{i(o.next(e))}catch(e){a(e)}}function l(e){try{i(o.throw(e))}catch(e){a(e)}}function i(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(r,l)}i((o=o.apply(e,t||[])).next())}))}const o=(e={},t,n,o)=>{const s=`/${t}`,a="function"==typeof e["/**"]?e["/**"]({key:t,path:n,value:o}):e["/**"],r="function"==typeof e["/*"]?e["/*"]({key:t,path:n,value:o}):e["/*"];let l={};if(s in e)l=e[s];else if(!a&&!r)return;return l="function"==typeof l?l({key:t,path:n,value:o}):l,r&&(l=Object.assign(Object.assign({},r),l)),a?Object.assign(Object.assign({"/**":e["/**"]},a),l):l},s=e=>{const t={},n=e.reduce(((e,t)=>(Object.keys(t).forEach((t=>e.add(t))),e)),new Set);for(const o of n.keys()){const n=e.filter((e=>o in e));if(1!==n.length){if("/"!==o.charAt(0))throw new Error(`Cannot merge rules. Duplicate key: ${o}. Rules should not have same Rule key`);t[o]=(e,t)=>{const a=n.map((n=>"function"==typeof n[o]?n[o](e,t):n[o]));return s(a)}}else t[o]=n[0][o]}return t},a=e=>"object"==typeof e&&null!==e,r=e=>Array.isArray(e),l=(e,l,i={})=>n(void 0,void 0,void 0,(function*(){var n,u;l=r(l)?l:[l];const c=r(i.rules)?s(i.rules):i.rules,f=[{data:e,state:i.state,path:[],keys:[],keyIndex:-1,rules:c}];for(;f.length>0;){const e=f[f.length-1];if(e.keyIndex>=e.keys.length){for(;null===(n=e.hooks)||void 0===n?void 0:n.length;)e.hooks.pop()();f.pop();continue}const s=e.keys[e.keyIndex++],[i,d,y]=f.length>1?[e.data[s],[...e.path,s],o(e.rules,s,[...e.path,s],e.data[s])]:[e.data,e.path,c];let p={value:i,path:d,key:s,state:e.state,rules:y};const h=[];for(const e of l){if(!e||"function"!=typeof e)continue;const n=null!==(u=yield e(p))&&void 0!==u?u:{},{terminate:o,done:s,exitHook:a}=n,r=t(n,["terminate","done","exitHook"]);if(o)return;if(p=Object.assign(Object.assign({},p),r),a&&h.push(a),s){p=null;break}}if(p&&a(p.value)){const e=r(p.value)?[...p.value.keys()]:Object.keys(p.value);f.push({hooks:h,state:p.state,data:p.value,path:d,keys:e,keyIndex:0,rules:p.rules})}else for(;h.length;)h.pop()()}})),i=(e,n,l={})=>{var i,u;n=r(n)?n:[n];const c=r(l.rules)?s(l.rules):l.rules,f=[{data:e,state:l.state,path:[],keys:[],keyIndex:-1,rules:c}];for(;f.length>0;){const e=f[f.length-1];if(e.keyIndex>=e.keys.length){for(;null===(i=e.hooks)||void 0===i?void 0:i.length;)e.hooks.pop()();f.pop();continue}const s=e.keys[e.keyIndex++],[l,d,y]=f.length>1?[e.data[s],[...e.path,s],o(e.rules,s,[...e.path,s],e.data[s])]:[e.data,e.path,c];let p={value:l,path:d,key:s,state:e.state,rules:y};const h=[];for(const e of n){if(!e||"function"!=typeof e)continue;const n=null!==(u=e(p))&&void 0!==u?u:{},{terminate:o,done:s,exitHook:a}=n,r=t(n,["terminate","done","exitHook"]);if(o)return;if(a&&h.push(a),p=Object.assign(Object.assign({},p),r),s){p=null;break}}if(p&&a(p.value)){const e=r(p.value)?[...p.value.keys()]:Object.keys(p.value);f.push({hooks:h,state:p.state,data:p.value,path:d,keys:e,keyIndex:0,rules:p.rules})}else for(;h.length;)h.pop()()}};e.clone=(e,t=[],o={})=>n(void 0,void 0,void 0,(function*(){t=Array.isArray(t)?t:[t];const s={},r=Object.assign({state:Object.assign(Object.assign({},o.state),{root:s,node:s})},o.rules?{rules:o.rules}:{});return yield l(e,[...t,({value:e,path:t,key:o,state:s})=>n(void 0,void 0,void 0,(function*(){return o=t.length?o:"#",s.node[o]=a(e)?Array.isArray(e)?[]:{}:e,{value:e,state:Object.assign(Object.assign({},s),{node:s.node[o]})}}))],r),s["#"]})),e.crawl=l,e.equal=(e,t)=>{if(e===t)return!0;let n=!0;return i(e,(({value:e,key:t,state:o})=>{const s=void 0===t?o.value:o.value[t],a={state:{value:s}};if(e===s)return a;if(n=!1,typeof e!=typeof s)return{done:!0};if(r(e)&&e.length!==s.length)return{terminate:!0};if("object"==typeof e&&null!==e){const t=Object.keys(e),n=Object.keys(s);if(t.length!==n.length||!t.every((e=>n.includes(e))))return{terminate:!0}}else if(e!==s)return{terminate:!0};return n=!0,a}),{state:{value:t}}),n},e.getNodeRules=o,e.isArray=r,e.isObject=a,e.mergeRules=s,e.syncClone=(e,t=[],n={})=>{t=Array.isArray(t)?t:[t];const o={},s=Object.assign({state:Object.assign(Object.assign({},n.state),{root:o,node:o})},n.rules?{rules:n.rules}:{});return i(e,[...t,({value:e,path:t,key:n,state:o})=>(n=t.length?n:"#",o.node[n]=a(e)?Array.isArray(e)?[]:{}:e,{value:e,state:Object.assign(Object.assign({},o),{node:o.node[n]})})],s),o["#"]},e.syncCrawl=i,e.transform=(e,t=[],o={})=>n(void 0,void 0,void 0,(function*(){t=r(t)?t:[t];const s={"#":e},i=Object.assign({state:Object.assign(Object.assign({},o.state),{root:s,node:s})},o.rules?{rules:o.rules}:{});return yield l(e,[...t,({value:e,path:t,key:o,state:s})=>n(void 0,void 0,void 0,(function*(){return o=t.length?o:"#",void 0===e?r(s.node)&&"number"==typeof o?s.node.splice(o,1):a(s.node)&&o in s.node&&delete s.node[o]:a(s.node)&&(s.node[o]=e),{value:e,state:s}}))],i),s["#"]})),Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=index.cjs.map
