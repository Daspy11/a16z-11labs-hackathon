/*!
 * json-crawl v0.4.2
 * Copyright (C) 2012-2023 Damir Yusipov
 * Date: Wed, 13 Dec 2023 19:13:27 GMT
 */
function e(e,t){var n={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&t.indexOf(o)<0&&(n[o]=e[o]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(o=Object.getOwnPropertySymbols(e);s<o.length;s++)t.indexOf(o[s])<0&&Object.prototype.propertyIsEnumerable.call(e,o[s])&&(n[o[s]]=e[o[s]])}return n}function t(e,t,n,o){return new(n||(n=Promise))((function(s,a){function r(e){try{i(o.next(e))}catch(e){a(e)}}function l(e){try{i(o.throw(e))}catch(e){a(e)}}function i(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(r,l)}i((o=o.apply(e,t||[])).next())}))}const n=(e={},t,n,o)=>{const s=`/${t}`,a="function"==typeof e["/**"]?e["/**"]({key:t,path:n,value:o}):e["/**"],r="function"==typeof e["/*"]?e["/*"]({key:t,path:n,value:o}):e["/*"];let l={};if(s in e)l=e[s];else if(!a&&!r)return;return l="function"==typeof l?l({key:t,path:n,value:o}):l,r&&(l=Object.assign(Object.assign({},r),l)),a?Object.assign(Object.assign({"/**":e["/**"]},a),l):l},o=e=>{const t={},n=e.reduce(((e,t)=>(Object.keys(t).forEach((t=>e.add(t))),e)),new Set);for(const s of n.keys()){const n=e.filter((e=>s in e));if(1!==n.length){if("/"!==s.charAt(0))throw new Error(`Cannot merge rules. Duplicate key: ${s}. Rules should not have same Rule key`);t[s]=(e,t)=>{const a=n.map((n=>"function"==typeof n[s]?n[s](e,t):n[s]));return o(a)}}else t[s]=n[0][s]}return t},s=e=>"object"==typeof e&&null!==e,a=e=>Array.isArray(e),r=(r,l,i={})=>t(void 0,void 0,void 0,(function*(){var t,u;l=a(l)?l:[l];const c=a(i.rules)?o(i.rules):i.rules,d=[{data:r,state:i.state,path:[],keys:[],keyIndex:-1,rules:c}];for(;d.length>0;){const o=d[d.length-1];if(o.keyIndex>=o.keys.length){for(;null===(t=o.hooks)||void 0===t?void 0:t.length;)o.hooks.pop()();d.pop();continue}const r=o.keys[o.keyIndex++],[i,f,y]=d.length>1?[o.data[r],[...o.path,r],n(o.rules,r,[...o.path,r],o.data[r])]:[o.data,o.path,c];let p={value:i,path:f,key:r,state:o.state,rules:y};const h=[];for(const t of l){if(!t||"function"!=typeof t)continue;const n=null!==(u=yield t(p))&&void 0!==u?u:{},{terminate:o,done:s,exitHook:a}=n,r=e(n,["terminate","done","exitHook"]);if(o)return;if(p=Object.assign(Object.assign({},p),r),a&&h.push(a),s){p=null;break}}if(p&&s(p.value)){const e=a(p.value)?[...p.value.keys()]:Object.keys(p.value);d.push({hooks:h,state:p.state,data:p.value,path:f,keys:e,keyIndex:0,rules:p.rules})}else for(;h.length;)h.pop()()}})),l=(t,r,l={})=>{var i,u;r=a(r)?r:[r];const c=a(l.rules)?o(l.rules):l.rules,d=[{data:t,state:l.state,path:[],keys:[],keyIndex:-1,rules:c}];for(;d.length>0;){const t=d[d.length-1];if(t.keyIndex>=t.keys.length){for(;null===(i=t.hooks)||void 0===i?void 0:i.length;)t.hooks.pop()();d.pop();continue}const o=t.keys[t.keyIndex++],[l,f,y]=d.length>1?[t.data[o],[...t.path,o],n(t.rules,o,[...t.path,o],t.data[o])]:[t.data,t.path,c];let p={value:l,path:f,key:o,state:t.state,rules:y};const h=[];for(const t of r){if(!t||"function"!=typeof t)continue;const n=null!==(u=t(p))&&void 0!==u?u:{},{terminate:o,done:s,exitHook:a}=n,r=e(n,["terminate","done","exitHook"]);if(o)return;if(a&&h.push(a),p=Object.assign(Object.assign({},p),r),s){p=null;break}}if(p&&s(p.value)){const e=a(p.value)?[...p.value.keys()]:Object.keys(p.value);d.push({hooks:h,state:p.state,data:p.value,path:f,keys:e,keyIndex:0,rules:p.rules})}else for(;h.length;)h.pop()()}},i=(e,n=[],o={})=>t(void 0,void 0,void 0,(function*(){n=Array.isArray(n)?n:[n];const a={},l=Object.assign({state:Object.assign(Object.assign({},o.state),{root:a,node:a})},o.rules?{rules:o.rules}:{});return yield r(e,[...n,({value:e,path:n,key:o,state:a})=>t(void 0,void 0,void 0,(function*(){return o=n.length?o:"#",a.node[o]=s(e)?Array.isArray(e)?[]:{}:e,{value:e,state:Object.assign(Object.assign({},a),{node:a.node[o]})}}))],l),a["#"]})),u=(e,t=[],n={})=>{t=Array.isArray(t)?t:[t];const o={},a=Object.assign({state:Object.assign(Object.assign({},n.state),{root:o,node:o})},n.rules?{rules:n.rules}:{});return l(e,[...t,({value:e,path:t,key:n,state:o})=>(n=t.length?n:"#",o.node[n]=s(e)?Array.isArray(e)?[]:{}:e,{value:e,state:Object.assign(Object.assign({},o),{node:o.node[n]})})],a),o["#"]},c=(e,t)=>{if(e===t)return!0;let n=!0;return l(e,(({value:e,key:t,state:o})=>{const s=void 0===t?o.value:o.value[t],r={state:{value:s}};if(e===s)return r;if(n=!1,typeof e!=typeof s)return{done:!0};if(a(e)&&e.length!==s.length)return{terminate:!0};if("object"==typeof e&&null!==e){const t=Object.keys(e),n=Object.keys(s);if(t.length!==n.length||!t.every((e=>n.includes(e))))return{terminate:!0}}else if(e!==s)return{terminate:!0};return n=!0,r}),{state:{value:t}}),n},d=(e,n=[],o={})=>t(void 0,void 0,void 0,(function*(){n=a(n)?n:[n];const l={"#":e},i=Object.assign({state:Object.assign(Object.assign({},o.state),{root:l,node:l})},o.rules?{rules:o.rules}:{});return yield r(e,[...n,({value:e,path:n,key:o,state:r})=>t(void 0,void 0,void 0,(function*(){return o=n.length?o:"#",void 0===e?a(r.node)&&"number"==typeof o?r.node.splice(o,1):s(r.node)&&o in r.node&&delete r.node[o]:s(r.node)&&(r.node[o]=e),{value:e,state:r}}))],i),l["#"]}));export{i as clone,r as crawl,c as equal,n as getNodeRules,a as isArray,s as isObject,o as mergeRules,u as syncClone,l as syncCrawl,d as transform};
//# sourceMappingURL=index.mjs.map
